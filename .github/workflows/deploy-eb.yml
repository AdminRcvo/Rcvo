name: Deploy to Elastic Beanstalk

# Triggers: manual + push to main (ajuste si besoin)
on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  S3_BUCKET: ${{ secrets.S3_BUCKET }}
  EB_APP: ${{ secrets.EB_APPLICATION_NAME }}
  EB_ENV: ${{ secrets.EB_ENVIRONMENT_NAME }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN || '' }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node (optional; used if you build frontend)
        uses: actions/setup-node@v4
        with:
          node-version: '20'   # change si besoin

      - name: (Optional) Build frontend if exists
        working-directory: ./ui
        if: ${{ matrix.skip == null && steps.checkout.outcome == 'success' && (exists('./ui/package.json') || false) }}
        run: |
          if [ -f ui/package.json ]; then
            cd ui
            npm ci
            npm run build || true
            cd ..
          fi
        shell: bash

      - name: Create dereferenced tarball (in TMP)
        id: make_tar
        run: |
          set -euo pipefail
          # nom unique
          TS=$(date -u +"%Y%m%d-%H%M%SZ")
          TAR_NAME="rcvo-deploy-${TS}.tar.gz"

          # dossier temporaire sûr
          TMPDIR=$(mktemp -d)
          echo "TMPDIR=${TMPDIR}"
          ARCHIVE_PATH="${TMPDIR}/${TAR_NAME}"

          echo "Creating stable snapshot: ${ARCHIVE_PATH}"
          # On archive le contenu du workspace, en excluant .git et .github
          # --warning=no-file-changed évite le message "file changed as we read it"
          tar --warning=no-file-changed -C "${GITHUB_WORKSPACE}" -czf "${ARCHIVE_PATH}" \
              --exclude='.git' --exclude='.github' .

          # affiche taille pour debug
          ls -lh "${ARCHIVE_PATH}"

          echo "archive_path=${ARCHIVE_PATH}" >> $GITHUB_OUTPUT
          echo "tar_name=${TAR_NAME}" >> $GITHUB_OUTPUT

      - name: Upload tarball to S3 (STANDARD)
        id: upload_s3
        run: |
          set -euo pipefail
          ARCHIVE_PATH="${{ steps.make_tar.outputs.archive_path }}"
          TAR_NAME="${{ steps.make_tar.outputs.tar_name }}"

          # clé S3 où l'on envoie (sous rcvo-backend/ pour compatibilité)
          S3_KEY="rcvo-backend/${TAR_NAME}"

          echo "Uploading ${ARCHIVE_PATH} to s3://${{ env.S3_BUCKET }}/${S3_KEY} (storage-class STANDARD)"
          # on force StorageClass STANDARD au moment de l'upload
          aws s3 cp "${ARCHIVE_PATH}" "s3://${{ env.S3_BUCKET }}/${S3_KEY}" --storage-class STANDARD --region "${{ env.AWS_REGION }}"

          # verification
          echo "Head object:"
          aws s3api head-object --bucket "${{ env.S3_BUCKET }}" --key "${S3_KEY}" --region "${{ env.AWS_REGION }}" --query '{Key:Key,StorageClass:StorageClass,Size:ContentLength}' --output json

          echo "s3_key=${S3_KEY}" >> $GITHUB_OUTPUT
          echo "version_label=manual-${TAR_NAME}" >> $GITHUB_OUTPUT

      - name: Create Elastic Beanstalk application version
        id: create_appver
        run: |
          set -euo pipefail
          S3_KEY="${{ steps.upload_s3.outputs.s3_key }}"
          VERSION_LABEL="${{ steps.upload_s3.outputs.version_label }}"

          echo "Creating app version ${VERSION_LABEL} -> s3://${{ env.S3_BUCKET }}/${S3_KEY}"
          aws elasticbeanstalk create-application-version \
            --application-name "${{ env.EB_APP }}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle S3Bucket="${{ env.S3_BUCKET }}",S3Key="${S3_KEY}" \
            --region "${{ env.AWS_REGION }}"

          # wait for it to be visible (short loop)
          for i in $(seq 1 10); do
            sleep 1
            FOUND=$(aws elasticbeanstalk describe-application-versions \
              --application-name "${{ env.EB_APP }}" \
              --version-label "${VERSION_LABEL}" \
              --region "${{ env.AWS_REGION }}" --query 'ApplicationVersions[0].VersionLabel' --output text || true)
            if [ "$FOUND" = "${VERSION_LABEL}" ]; then
              echo "Application version ready."
              exit 0
            fi
            echo "waiting for app version to appear..."
          done
          echo "WARN: application version may not be fully visible yet"

      - name: Deploy new version to EB environment
        id: deploy_env
        run: |
          set -euo pipefail
          VERSION_LABEL="${{ steps.upload_s3.outputs.version_label }}"

          echo "Updating environment ${{ env.EB_ENV }} -> version ${VERSION_LABEL}"
          aws elasticbeanstalk update-environment \
            --environment-name "${{ env.EB_ENV }}" \
            --version-label "${VERSION_LABEL}" \
            --region "${{ env.AWS_REGION }}"

          echo "Describe environment:"
          aws elasticbeanstalk describe-environments \
            --environment-names "${{ env.EB_ENV }}" \
            --region "${{ env.AWS_REGION }}" \
            --query 'Environments[0].[EnvironmentName,Status,Health,VersionLabel,DateUpdated]' --output table

      - name: Cleanup TMP (best effort)
        if: always()
        run: |
          set -euo pipefail
          if [ -n "${{ steps.make_tar.outputs.archive_path }}" ]; then
            TMPDIR=$(dirname "${{ steps.make_tar.outputs.archive_path }}" )
            echo "Cleaning up TMPDIR ${TMPDIR}"
            rm -rf "${TMPDIR}" || true
          fi
