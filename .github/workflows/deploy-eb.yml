name: Deploy to Elastic Beanstalk

on:
  push:
    branches: [ "main" ]

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy to Elastic Beanstalk
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      S3_BUCKET: ${{ secrets.S3_BUCKET }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install jq (optional, used for debug)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      # Detect UI folder presence and publish an output
      - id: detect_ui
        name: Detect UI presence (./ui/package.json)
        run: |
          if [ -f "./ui/package.json" ]; then
            echo "ui_present=true" >> "$GITHUB_OUTPUT"
          else
            echo "ui_present=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup Node (if UI present)
        if: ${{ steps.detect_ui.outputs.ui_present == 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Build frontend (if UI present)
        if: ${{ steps.detect_ui.outputs.ui_present == 'true' }}
        run: |
          cd ui
          npm ci
          npm run build --if-present
          cd -

      # Create tarball in a temp dir (safe, avoids same-file mv)
      - id: make_tar
        name: Create stable snapshot tarball (safe, in temp dir)
        run: |
          set -euo pipefail

          # read EB app/env names from secrets via env set below (safer)
          if [ -z "${EB_APP_NAME:-}" ] || [ -z "${EB_ENV_NAME:-}" ]; then
            echo "ERROR: EB_APP_NAME and EB_ENV_NAME must be set in repository Secrets."
            exit 2
          fi

          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-8)
          TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
          ARCHIVE_NAME="rcvo-deploy-${TIMESTAMP}-${SHORT_SHA}.tar.gz"

          TMPDIR=$(mktemp -d)
          ARCHIVE_PATH="${TMPDIR}/${ARCHIVE_NAME}"

          echo "Creating archive at ${ARCHIVE_PATH} (excluded: .git, node_modules, ui/node_modules)"
          tar --exclude='.git' --exclude='node_modules' --exclude='ui/node_modules' -czf "${ARCHIVE_PATH}" .

          # export outputs
          echo "archive_path=${ARCHIVE_PATH}" >> "$GITHUB_OUTPUT"
          echo "archive_name=${ARCHIVE_NAME}" >> "$GITHUB_OUTPUT"
        env:
          EB_APP_NAME: ${{ secrets.EB_APP_NAME }}
          EB_ENV_NAME: ${{ secrets.EB_ENV_NAME }}

      - id: upload_s3
        name: Upload tarball to S3 (STANDARD) and confirm storage class
        env:
          ARCHIVE_PATH: ${{ steps.make_tar.outputs.archive_path }}
          ARCHIVE_NAME: ${{ steps.make_tar.outputs.archive_name }}
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail

          S3_KEY="archive/${ARCHIVE_NAME}"

          echo "Uploading ${ARCHIVE_PATH} to s3://${S3_BUCKET}/${S3_KEY} (STANDARD)"
          aws s3 cp "${ARCHIVE_PATH}" "s3://${S3_BUCKET}/${S3_KEY}" --storage-class STANDARD --only-show-errors

          # head-object may not return StorageClass for STANDARD (it returns nothing),
          # so treat empty as STANDARD.
          SC=$(aws s3api head-object --bucket "${S3_BUCKET}" --key "${S3_KEY}" --query 'StorageClass' --output text 2>/dev/null || echo "")
          if [ -z "${SC}" ] || [ "${SC}" = "STANDARD" ]; then
            echo "StorageClass for s3://${S3_BUCKET}/${S3_KEY} => ${SC:-STANDARD}"
          else
            echo "ERROR: uploaded object storage class is not STANDARD (found: ${SC})"
            exit 3
          fi

          # set outputs
          echo "s3_key=${S3_KEY}" >> "$GITHUB_OUTPUT"
          echo "s3_bucket=${S3_BUCKET}" >> "$GITHUB_OUTPUT"

      - id: create_app_version
        name: Create EB application version
        env:
          EB_APP_NAME: ${{ secrets.EB_APP_NAME }}
          ARCHIVE_S3_KEY: ${{ steps.upload_s3.outputs.s3_key }}
          ARCHIVE_S3_BUCKET: ${{ steps.upload_s3.outputs.s3_bucket }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail

          APP="${EB_APP_NAME:-}"
          if [ -z "${APP}" ]; then
            echo "ERROR: EB_APP_NAME not set (Secrets)."
            exit 4
          fi

          VERSION_LABEL="deploy-${GITHUB_RUN_ID}-${GITHUB_RUN_NUMBER}-$(echo ${GITHUB_SHA} | cut -c1-8)"

          echo "Creating application version '${VERSION_LABEL}' for app '${APP}' from s3://${ARCHIVE_S3_BUCKET}/${ARCHIVE_S3_KEY}"

          aws elasticbeanstalk create-application-version \
            --application-name "${APP}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle S3Bucket="${ARCHIVE_S3_BUCKET}",S3Key="${ARCHIVE_S3_KEY}" \
            --region "${AWS_REGION}" \
            --auto-create-application || {
              echo "ERROR: create-application-version failed"
              exit 5
            }

          echo "version_label=${VERSION_LABEL}" >> "$GITHUB_OUTPUT"

      - id: wait_version
        name: Wait for application version visible
        env:
          APP: ${{ secrets.EB_APP_NAME }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          VERSION="${{ steps.create_app_version.outputs.version_label }}"
          APP="${APP}"
          echo "Waiting for application version ${VERSION} to appear for app ${APP} ..."

          for i in $(seq 1 12); do
            FOUND=$(aws elasticbeanstalk describe-application-versions \
              --application-name "${APP}" \
              --version-labels "${VERSION}" \
              --region "${AWS_REGION}" \
              --query 'ApplicationVersions[0].VersionLabel' --output text || echo "")
            if [ "${FOUND}" = "${VERSION}" ]; then
              echo "Application version visible."
              exit 0
            fi
            echo "Not yet visible, sleeping 5s..."
            sleep 5
          done

          echo "ERROR: application version did not appear in time."
          exit 6

      - id: update_env
        name: Deploy new version to EB environment
        env:
          EB_ENV_NAME: ${{ secrets.EB_ENV_NAME }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          ENVNAME="${EB_ENV_NAME:-}"
          VERSION="${{ steps.create_app_version.outputs.version_label }}"
          if [ -z "${ENVNAME}" ]; then
            echo "ERROR: EB_ENV_NAME secret is not set."
            exit 7
          fi

          echo "Updating environment ${ENVNAME} -> version ${VERSION}"
          aws elasticbeanstalk update-environment \
            --environment-name "${ENVNAME}" \
            --version-label "${VERSION}" \
            --region "${AWS_REGION}"

      - name: Cleanup TMP (best-effort)
        if: always()
        run: |
          set +e
          ARCHIVE_PATH="${{ steps.make_tar.outputs.archive_path }}"
          if [ -n "${ARCHIVE_PATH:-}" ] && [ -f "${ARCHIVE_PATH}" ]; then
            rm -f "${ARCHIVE_PATH}" || true
          fi
