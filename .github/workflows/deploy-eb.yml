name: Deploy to Elastic Beanstalk

on:
  push:
    branches: [ "main" ]

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy to Elastic Beanstalk
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      S3_BUCKET: ${{ secrets.S3_BUCKET }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install jq (for debugging / optional)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      # -----------------------------
      # Detect UI presence (. /ui/package.json)
      # -----------------------------
      - id: detect_ui
        name: Detect UI presence (./ui/package.json)
        run: |
          if [ -f "./ui/package.json" ]; then
            echo "ui_present=true" >> "$GITHUB_OUTPUT"
          else
            echo "ui_present=false" >> "$GITHUB_OUTPUT"
          fi

      # -----------------------------
      # Setup node (only if UI present)
      # -----------------------------
      - name: Setup Node.js (if UI present)
        if: ${{ steps.detect_ui.outputs.ui_present == 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Build frontend (if UI present)
        if: ${{ steps.detect_ui.outputs.ui_present == 'true' }}
        run: |
          cd ui
          npm ci
          # adapt your build command if needed:
          npm run build --if-present
          cd -

      # -----------------------------
      # Create stable snapshot tarball (in temp dir)
      # -----------------------------
      - id: make_tar
        name: Create stable snapshot tarball (safe, in temp dir)
        run: |
          set -euo pipefail

          # require EB secrets exist (clear error if not)
          if [ -z "${{ secrets.EB_APP_NAME }}" ] || [ -z "${{ secrets.EB_ENV_NAME }}" ]; then
            echo "ERROR: EB_APP_NAME and EB_ENV_NAME must be set in repository Secrets."
            exit 2
          fi

          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-8)
          TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
          ARCHIVE_NAME="rcvo-deploy-${TIMESTAMP}-${SHORT_SHA}.tar.gz"

          TMPDIR=$(mktemp -d)
          ARCHIVE_PATH="${TMPDIR}/${ARCHIVE_NAME}"

          echo "Creating archive: ${ARCHIVE_PATH}"

          # change to repo root and create tar excluding .git and node_modules (adjust excludes if necessary)
          # we use -C . . so tar content root is repo root
          tar --exclude='.git' --exclude='node_modules' --exclude='ui/node_modules' -czf "${ARCHIVE_PATH}" .

          echo "archive_path=${ARCHIVE_PATH}" >> "$GITHUB_OUTPUT"
          echo "archive_name=${ARCHIVE_NAME}" >> "$GITHUB_OUTPUT"

      # -----------------------------
      # Upload to S3 and confirm STANDARD
      # -----------------------------
      - id: upload_s3
        name: Upload tarball to S3 (STANDARD) and confirm storage class
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
        run: |
          set -euo pipefail
          ARCHIVE_PATH="${{ steps.make_tar.outputs.archive_path }}"
          ARCHIVE_NAME="${{ steps.make_tar.outputs.archive_name }}"
          S3_KEY="archive/${ARCHIVE_NAME}"

          echo "Uploading ${ARCHIVE_PATH} to s3://${S3_BUCKET}/${S3_KEY} (STANDARD)"
          aws s3 cp "${ARCHIVE_PATH}" "s3://${S3_BUCKET}/${S3_KEY}" --storage-class STANDARD --only-show-errors

          # verify storage class (text output to avoid jq parsing issues)
          SC=$(aws s3api head-object --bucket "${S3_BUCKET}" --key "${S3_KEY}" --query 'StorageClass' --output text)
          echo "StorageClass for s3://${S3_BUCKET}/${S3_KEY} => ${SC}"
          if [ "${SC}" != "STANDARD" ]; then
            echo "ERROR: uploaded object storage class is not STANDARD (found: ${SC})"
            exit 3
          fi

          echo "s3_key=${S3_KEY}" >> "$GITHUB_OUTPUT"
          echo "s3_bucket=${S3_BUCKET}" >> "$GITHUB_OUTPUT"

      # -----------------------------
      # Create EB application version
      # -----------------------------
      - id: create_app_version
        name: Create EB application version
        env:
          EB_APP_NAME: ${{ secrets.EB_APP_NAME }}
          ARCHIVE_S3_KEY: ${{ steps.upload_s3.outputs.s3_key }}
          ARCHIVE_S3_BUCKET: ${{ steps.upload_s3.outputs.s3_bucket }}
        run: |
          set -euo pipefail

          APP="${EB_APP_NAME}"
          if [ -z "${APP}" ]; then
            echo "ERROR: EB_APP_NAME not set (Secrets)."
            exit 4
          fi

          # create a clean version label
          VERSION_LABEL="deploy-${GITHUB_RUN_ID}-${GITHUB_RUN_NUMBER}-$(echo ${GITHUB_SHA} | cut -c1-8)"
          echo "Creating application version '${VERSION_LABEL}' for app '${APP}' from s3://${ARCHIVE_S3_BUCKET}/${ARCHIVE_S3_KEY}"

          aws elasticbeanstalk create-application-version \
            --application-name "${APP}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle S3Bucket="${ARCHIVE_S3_BUCKET}",S3Key="${ARCHIVE_S3_KEY}" \
            --region "${AWS_REGION}" \
            --auto-create-application || {
              echo "ERROR: create-application-version failed"
              exit 5
            }

          echo "version_label=${VERSION_LABEL}" >> "$GITHUB_OUTPUT"

      # -----------------------------
      # Wait for application version visible (short loop)
      # -----------------------------
      - id: wait_version
        name: Wait for application version visible
        env:
          APP: ${{ secrets.EB_APP_NAME }}
        run: |
          set -euo pipefail
          VERSION="${{ steps.create_app_version.outputs.version_label }}"
          APP="${APP}"
          echo "Waiting for application version ${VERSION} to appear for app ${APP} ..."

          for i in $(seq 1 12); do
            FOUND=$(aws elasticbeanstalk describe-application-versions \
              --application-name "${APP}" \
              --version-labels "${VERSION}" \
              --region "${AWS_REGION}" \
              --query 'ApplicationVersions[0].VersionLabel' --output text || echo "")
            if [ "${FOUND}" = "${VERSION}" ]; then
              echo "Application version visible."
              exit 0
            fi
            echo "Not yet visible, sleeping 5s..."
            sleep 5
          done

          echo "ERROR: application version did not appear in time."
          exit 6

      # -----------------------------
      # Deploy new version to EB environment
      # -----------------------------
      - id: update_env
        name: Deploy new version to EB environment
        env:
          EB_ENV_NAME: ${{ secrets.EB_ENV_NAME }}
          EB_APP_NAME: ${{ secrets.EB_APP_NAME }}
        run: |
          set -euo pipefail
          ENVNAME="${EB_ENV_NAME}"
          VERSION="${{ steps.create_app_version.outputs.version_label }}"
          if [ -z "${ENVNAME}" ]; then
            echo "ERROR: EB_ENV_NAME secret is not set."
            exit 7
          fi

          echo "Updating environment ${ENVNAME} -> version ${VERSION}"
          aws elasticbeanstalk update-environment \
            --environment-name "${ENVNAME}" \
            --version-label "${VERSION}" \
            --region "${AWS_REGION}"

      # -----------------------------
      # (best-effort) Cleanup TMP
      # -----------------------------
      - name: Cleanup TMP (best-effort)
        if: always()
        run: |
          set +e
          ARCHIVE_PATH="${{ steps.make_tar.outputs.archive_path }}"
          if [ -n "${ARCHIVE_PATH:-}" ] && [ -f "${ARCHIVE_PATH}" ]; then
            rm -f "${ARCHIVE_PATH}" || true
          fi
