name: Deploy to Elastic Beanstalk

on:
  push:
    branches: [ main ]

permissions:
  contents: read

env:
  # Values must exist as repository Secrets; if some are omitted, the workflow will error early with a clear message.
  AWS_REGION: ${{ secrets.AWS_REGION }}
  S3_BUCKET: ${{ secrets.S3_BUCKET }}
  S3_PREFIX: ${{ secrets.S3_PREFIX }}   # optional: if empty, step will default to 'rcvo-backend'
  ARCHIVE_PREFIX: archive
  EB_APP_NAME: ${{ secrets.EB_APP_NAME }}
  EB_ENV_NAME: ${{ secrets.EB_ENV_NAME }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout code
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN || '' }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Detect UI (./ui/package.json) presence
        id: detect_ui
        run: |
          if [ -f "./ui/package.json" ]; then
            echo "ui_present=true" >> $GITHUB_OUTPUT
          else
            echo "ui_present=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node (if UI present)
        if: steps.detect_ui.outputs.ui_present == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build frontend (if UI present)
        if: steps.detect_ui.outputs.ui_present == 'true'
        working-directory: ./ui
        run: |
          set -euo pipefail
          npm ci
          npm run build || true

      - name: Create stable snapshot tarball (safe, in temp dir)
        id: make_tar
        run: |
          set -euo pipefail

          # Validate required secrets early with clear error codes
          if [ -z "${EB_APP_NAME:-}" ] || [ -z "${EB_ENV_NAME:-}" ]; then
            echo "ERROR: EB_APP_NAME and EB_ENV_NAME must be set in repository Secrets."
            exit 2
          fi
          if [ -z "${S3_BUCKET:-}" ]; then
            echo "ERROR: S3_BUCKET must be set in repository Secrets."
            exit 2
          fi

          TS=$(date -u +%Y%m%d-%H%M%S)
          SHORT_SHA=${GITHUB_SHA::8}
          TAR_NAME="rcvo-deploy-${TS}-${SHORT_SHA}.tar.gz"

          TMPDIR=$(mktemp -d)
          echo "Creating stable snapshot: ${TAR_NAME} in ${TMPDIR}"

          # Archive workspace contents excluding .git and .github to avoid changing files while reading
          # -C to change into GITHUB_WORKSPACE and archive content; tar written to TMPDIR
          tar --exclude='.git' --exclude='.github' -czf "${TMPDIR}/${TAR_NAME}" -C "${GITHUB_WORKSPACE}" .

          if [ ! -f "${TMPDIR}/${TAR_NAME}" ]; then
            echo "ERROR creating tarball"
            exit 1
          fi

          echo "archive_path=${TMPDIR}/${TAR_NAME}" >> $GITHUB_OUTPUT
          echo "archive_name=${TAR_NAME}" >> $GITHUB_OUTPUT
          echo "tmpdir=${TMPDIR}" >> $GITHUB_OUTPUT

      - name: Upload tarball to S3 (STANDARD) and confirm storage class
        id: upload_s3
        run: |
          set -euo pipefail
          ARCHIVE_PATH="${{ steps.make_tar.outputs.archive_path }}"

          # compute prefix with fallback in shell (no '||' inside expressions)
          PREFIX="${{ env.S3_PREFIX }}"
          if [ -z "$PREFIX" ]; then
            PREFIX="rcvo-backend"
          fi

          BUCKET="${{ env.S3_BUCKET }}"
          ARCHIVE_NAME="${{ steps.make_tar.outputs.archive_name }}"
          ARCHIVE_KEY="${{ env.ARCHIVE_PREFIX }}/${ARCHIVE_NAME}"

          echo "Uploading ${ARCHIVE_PATH} to s3://${BUCKET}/${ARCHIVE_KEY} (STANDARD)"
          aws s3 cp "${ARCHIVE_PATH}" "s3://${BUCKET}/${ARCHIVE_KEY}" --storage-class STANDARD --region "${{ env.AWS_REGION }}"

          OBJ_JSON=$(aws s3api head-object --bucket "$BUCKET" --key "${ARCHIVE_KEY}" --region "${{ env.AWS_REGION }}" --output json)
          echo "s3_head=${OBJ_JSON}" >> $GITHUB_OUTPUT
          echo "s3_key=${ARCHIVE_KEY}" >> $GITHUB_OUTPUT

      - name: Create EB application version
        id: create_app_version
        run: |
          set -euo pipefail
          BUCKET="${{ env.S3_BUCKET }}"
          S3_KEY="${{ steps.upload_s3.outputs.s3_key }}"
          APP_NAME="${{ env.EB_APP_NAME }}"
          VERSION_LABEL="gh-${GITHUB_RUN_NUMBER}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"

          if [ -z "$APP_NAME" ]; then
            echo "ERROR: EB_APP_NAME must be set as a repo secret."
            exit 2
          fi

          echo "Creating application version ${VERSION_LABEL} pointing to s3://${BUCKET}/${S3_KEY}"
          aws elasticbeanstalk create-application-version \
            --application-name "$APP_NAME" \
            --version-label "$VERSION_LABEL" \
            --source-bundle S3Bucket="$BUCKET",S3Key="$S3_KEY" \
            --region "${{ env.AWS_REGION }}" \
            --auto-create-application || true

          echo "version_label=${VERSION_LABEL}" >> $GITHUB_OUTPUT

      - name: Wait for application version visible
        id: wait_version
        run: |
          set -euo pipefail
          APP_NAME="${{ env.EB_APP_NAME }}"
          VERSION_LABEL="${{ steps.create_app_version.outputs.version_label }}"
          REGION="${{ env.AWS_REGION }}"

          for i in $(seq 1 30); do
            OUT=$(aws elasticbeanstalk describe-application-versions \
              --application-name "$APP_NAME" \
              --version-labels "$VERSION_LABEL" \
              --region "$REGION" --output json 2>/dev/null || true)
            count=$(echo "$OUT" | jq '.ApplicationVersions | length' 2>/dev/null || echo 0)
            if [ "$count" != "0" ]; then
              echo "found"
              exit 0
            fi
            sleep 2
          done

          echo "WARN: application version not visible after timeout (but continuing)."
          exit 0

      - name: Deploy new version to EB environment
        id: deploy_env
        run: |
          set -euo pipefail
          ENV_NAME="${{ env.EB_ENV_NAME }}"
          APP_NAME="${{ env.EB_APP_NAME }}"
          VERSION_LABEL="${{ steps.create_app_version.outputs.version_label }}"
          REGION="${{ env.AWS_REGION }}"

          if [ -z "$ENV_NAME" ]; then
            echo "ERROR: EB_ENV_NAME must be set as a repo secret."
            exit 2
          fi

          echo "Updating environment ${ENV_NAME} -> version ${VERSION_LABEL}"
          aws elasticbeanstalk update-environment \
            --environment-name "$ENV_NAME" \
            --version-label "$VERSION_LABEL" \
            --region "$REGION"

      - name: Describe environment (short summary)
        run: |
          set -euo pipefail
          ENV_NAME="${{ env.EB_ENV_NAME }}"
          REGION="${{ env.AWS_REGION }}"
          aws elasticbeanstalk describe-environments \
            --environment-names "$ENV_NAME" \
            --region "$REGION" \
            --query 'Environments[0].[EnvironmentName,Status,Health,VersionLabel,DateUpdated]' \
            --output table || true

      - name: Cleanup TMP (best-effort)
        if: always()
        continue-on-error: true
        run: |
          set -euo pipefail
          TMPDIR="${{ steps.make_tar.outputs.tmpdir }}"
          if [ -n "$TMPDIR" ] && [ -d "$TMPDIR" ]; then
            echo "Cleaning tmpdir $TMPDIR"
            rm -rf "$TMPDIR"
          else
            echo "No tmpdir to clean"
          fi
