name: Deploy to Elastic Beanstalk

on:
  workflow_dispatch:
  push:
    branches:
      - main   # change si besoin

permissions:
  id-token: write   # OIDC obligatoire
  contents: read

env:
  AWS_REGION: eu-west-3
  EB_APP: Rcvo-backend
  EB_ENV: rcvo-backend-b
  EB_BUCKET: elasticbeanstalk-eu-west-3-409818814260
  ROLE_ARN: arn:aws:iam::409818814260:role/GithubDeployRole

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: rcvo-${{ github.run_id }}
          output-env-credentials: true

      - name: Tooling
        shell: bash
        run: |
          set -euo pipefail
          aws --version
          zip --version || sudo apt-get update -y && sudo apt-get install -y zip

      - name: Package app (zip)
        shell: bash
        run: |
          set -euo pipefail
          LABEL="ops-deploy-$(date +%Y%m%d-%H%M%S)-$RANDOM"
          echo "LABEL=$LABEL" >> $GITHUB_ENV
          echo "S3_KEY=${EB_APP}/${LABEL}.zip" >> $GITHUB_ENV

          # zip le dépôt (exclut .git et .github et le zip lui-même)
          ZIP="${LABEL}.zip"
          zip -qr "$ZIP" . -x ".git/*" ".github/*" "$ZIP"

          echo "Archive: $ZIP"
          ls -lh "$ZIP"

      - name: Upload to S3 (unique key)
        shell: bash
        run: |
          set -euo pipefail
          aws s3 cp "${LABEL}.zip" "s3://${EB_BUCKET}/${S3_KEY}"

      - name: Create EB Application Version (process) — always unique
        shell: bash
        run: |
          set -euo pipefail
          # Idempotent (ignore "already exists" si jamais)
          set +e
          out=$(aws elasticbeanstalk create-application-version \
            --application-name "$EB_APP" \
            --version-label "$LABEL" \
            --source-bundle S3Bucket="$EB_BUCKET",S3Key="$S3_KEY" \
            --process 2>&1)
          rc=$?
          set -e
          if [ $rc -ne 0 ] && ! grep -qi 'already exists' <<<"$out"; then
            echo "$out" >&2
            exit $rc
          fi
          echo "AppVersion $LABEL OK"

      - name: Update Environment
        shell: bash
        run: |
          set -euo pipefail
          aws elasticbeanstalk update-environment \
            --environment-name "$EB_ENV" \
            --version-label "$LABEL"

      - name: Wait until Ready/Green (≤15 min)
        shell: bash
        run: |
          set -euo pipefail
          end=$((SECONDS+900))
          stale_count=0
          last=""

          while [ $SECONDS -lt $end ]; do
            read -r ST H V < <(aws elasticbeanstalk describe-environments \
              --environment-names "$EB_ENV" \
              --query 'Environments[0].[Status,Health,VersionLabel]' --output text)

            echo "Status=$ST Health=$H Version=$V"
            last="Status=$ST Health=$H Version=$V"

            # Succès quand Ready + bon label + santé OK/Green/Yellow
            if [[ "$ST" == "Ready" && "$V" == "$LABEL" && "$H" =~ ^(Ok|Green|Yellow)$ ]]; then
              echo "✅ Déployé: $LABEL (Health=$H)"
              exit 0
            fi

            # Si Ready mais V != LABEL, on considère que la bascule n'a pas pris.
            if [[ "$ST" == "Ready" && "$V" != "$LABEL" ]]; then
              ((stale_count+=1))
              if [ $stale_count -ge 10 ]; then
                echo "❌ L'environnement reste sur $V au lieu de $LABEL."
                exit 2
              fi
            fi

            sleep 10
          done

          echo "⏰ Timeout d'attente. Dernier état: $last"
          exit 1

      - name: EB events (si échec)
        if: failure()
        shell: bash
        run: |
          set -euo pipefail
          aws elasticbeanstalk describe-events \
            --environment-name "$EB_ENV" \
            --start-time "$(date -u -d '30 minutes ago' +%FT%TZ)" \
            --query 'reverse(Events)[].[EventDate,Severity,Message]' \
            --output table || true
