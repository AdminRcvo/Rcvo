# .github/workflows/deploy-eb.yml
name: Deploy to Elastic Beanstalk

on:
  push:
    branches:
      - main

permissions:
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  S3_BUCKET: ${{ secrets.S3_BUCKET }}
  EB_APPLICATION_NAME: ${{ secrets.EB_APPLICATION_NAME }}
  EB_ENVIRONMENT_NAME: ${{ secrets.EB_ENVIRONMENT_NAME }}
  S3_ARCHIVE_PREFIX: rcvo-backend

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout code
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check for UI (detect ./ui/package.json)
        id: check-ui
        run: |
          if [ -f "./ui/package.json" ]; then
            echo "ui_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "ui_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup Node.js (for frontend build if present)
        if: steps.check-ui.outputs.ui_exists == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Build frontend (if exists)
        if: steps.check-ui.outputs.ui_exists == 'true'
        working-directory: ./ui
        run: |
          npm ci
          npm run build || true

      - name: Create dereferenced tarball (stable snapshot)
        id: make_tar
        run: |
          set -euo pipefail
          # temp dir outside repo to avoid self-inclusion
          TMPDIR="${RUNNER_TEMP:-/tmp}/rcvo-deploy-${GITHUB_RUN_ID}"
          mkdir -p "$TMPDIR"
          TAR_NAME="rcvo-deploy-${GITHUB_RUN_NUMBER}-${GITHUB_RUN_ID}.tar.gz"
          TAR_PATH="${TMPDIR}/${TAR_NAME}"
          echo "TMPDIR=${TMPDIR}"
          echo "TAR_PATH=${TAR_PATH}"

          # Build an archive of tracked files only (git ls-files).
          # Use --null to be safe with filenames, and tell tar to ignore file-changed warnings.
          git ls-files -z > "${TMPDIR}/filelist.null"
          # Optionally exclude .github by filtering filelist; uncomment if needed:
          # grep -zv '^.github/' "${TMPDIR}/filelist.null" > "${TMPDIR}/filelist.filtered.null" || true
          # TAR_SOURCE="${TMPDIR}/filelist.filtered.null"
          TAR_SOURCE="${TMPDIR}/filelist.null"

          # Create tar gz from file list
          tar --null --files-from="${TAR_SOURCE}" --warning=no-file-changed -czf "${TAR_PATH}"

          # Publish outputs for later steps
          echo "TAR_CREATED_PATH=${TAR_PATH}" >> "$GITHUB_OUTPUT"
          echo "TAR_NAME=${TAR_NAME}" >> "$GITHUB_OUTPUT"
          ls -lh "${TAR_PATH}" || true

      - name: Upload tarball to S3 (STANDARD) and confirm storage class
        id: upload_s3
        run: |
          set -euo pipefail
          TAR_PATH="${{ steps.make_tar.outputs.TAR_CREATED_PATH }}"
          TAR_NAME="${{ steps.make_tar.outputs.TAR_NAME }}"
          DEST_KEY="${S3_ARCHIVE_PREFIX}/${TAR_NAME}"
          echo "Uploading ${TAR_PATH} to s3://${S3_BUCKET}/${DEST_KEY}"
          aws s3 cp "${TAR_PATH}" "s3://${S3_BUCKET}/${DEST_KEY}" --storage-class STANDARD --region "${AWS_REGION}"
          # Inspect head
          HEAD_JSON=$(aws s3api head-object --bucket "${S3_BUCKET}" --key "${DEST_KEY}" --region "${AWS_REGION}" --query '{Key:Key,StorageClass:StorageClass,Size:ContentLength}' --output json)
          echo "${HEAD_JSON}"
          # export as step output
          echo "s3_key=${DEST_KEY}" >> "$GITHUB_OUTPUT"

      - name: Create EB application version
        id: create_app_version
        run: |
          set -euo pipefail
          DEST_KEY="${{ steps.upload_s3.outputs.s3_key }}"
          VERSION_LABEL="gh-${GITHUB_RUN_NUMBER}-${GITHUB_RUN_ID}"
          echo "Creating application version ${VERSION_LABEL} pointing to s3://${S3_BUCKET}/${DEST_KEY}"
          aws elasticbeanstalk create-application-version \
            --application-name "${EB_APPLICATION_NAME}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle S3Bucket="${S3_BUCKET}",S3Key="${DEST_KEY}" \
            --region "${AWS_REGION}"
          echo "version_label=${VERSION_LABEL}" >> "$GITHUB_OUTPUT"

      - name: Wait for application version visible
        run: |
          set -euo pipefail
          VERSION_LABEL="${{ steps.create_app_version.outputs.version_label }}"
          APP="${EB_APPLICATION_NAME}"
          REGION="${AWS_REGION}"
          for i in $(seq 1 20); do
            COUNT=$(aws elasticbeanstalk describe-application-versions --application-name "${APP}" --region "${REGION}" --query "length(ApplicationVersions[?VersionLabel=='${VERSION_LABEL}'])" --output text || echo "0")
            if [ "${COUNT}" != "0" ]; then
              echo "Version ${VERSION_LABEL} visible."
              exit 0
            fi
            sleep 3
          done
          echo "WARNING: application version may not be fully visible yet."

      - name: Deploy new version to EB environment
        id: deploy_env
        run: |
          set -euo pipefail
          VERSION_LABEL="${{ steps.create_app_version.outputs.version_label }}"
          ENV_NAME="${EB_ENVIRONMENT_NAME}"
          REGION="${AWS_REGION}"
          echo "Updating environment ${ENV_NAME} to version ${VERSION_LABEL}"
          aws elasticbeanstalk update-environment \
            --environment-name "${ENV_NAME}" \
            --version-label "${VERSION_LABEL}" \
            --region "${REGION}"
          echo "deploy_requested=true" >> "$GITHUB_OUTPUT"

      - name: Describe environment (short summary)
        run: |
          set -euo pipefail
          ENV_NAME="${EB_ENVIRONMENT_NAME}"
          REGION="${AWS_REGION}"
          aws elasticbeanstalk describe-environments \
            --environment-names "${ENV_NAME}" \
            --region "${REGION}" \
            --query 'Environments[0].[EnvironmentName,Status,Health,VersionLabel,DateUpdated]' --output table

      - name: Cleanup TMP (best-effort)
        if: always()
        run: |
          set -euo pipefail
          TARPATH="${{ steps.make_tar.outputs.TAR_CREATED_PATH }}"
          if [ -n "$TARPATH" ] && [ -f "$TARPATH" ]; then
            rm -fv "$TARPATH" || true
          fi
